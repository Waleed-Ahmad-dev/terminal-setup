#!/usr/bin/env python3
import subprocess
import os
import sys
import json
import urllib.request
import urllib.error
import tempfile
import re

# --- CONFIGURATION ---
# 1. GROQ (Hardcoded Key)
# GROQ_API_KEY = "API-KEY"
GROQ_MODEL = "llama-3.3-70b-versatile"

# 2. OLLAMA (Local Fallback)
OLLAMA_MODEL = "qwen2.5-coder:1.5b"
OLLAMA_API_URL = "http://localhost:11434/api/generate"
# ---------------------

def run_command(command, allow_error=False):
    """Runs a shell command and returns the output."""
    try:
        result = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT)
        return result.decode('utf-8').strip()
    except subprocess.CalledProcessError as e:
        if allow_error:
            return e.output.decode('utf-8').strip()
        print(f"\n[!] Command failed: {command}")
        print(f"[!] Error message: {e.output.decode('utf-8').strip()}")
        sys.exit(1)

def get_recent_commits(limit=5):
    """Fetches the last N commit messages to learn style."""
    try:
        log = run_command(f"git log -n {limit} --pretty=format:'%B%n---COMMIT_DELIMITER---'", allow_error=True)
        if not log: return ""
        commits = log.split("---COMMIT_DELIMITER---")
        examples = []
        for c in commits:
            clean = c.strip()
            if clean:
                examples.append(f"Recent Example:\n{clean}")
        return "\n\n".join(examples)
    except Exception:
        return ""

def call_groq_api(prompt):
    """Calls Groq API using the hardcoded key."""
    url = "https://api.groq.com/openai/v1/chat/completions"
    data = {
        "model": GROQ_MODEL,
        "messages": [
            {
                "role": "system",
                "content": "You are an expert Git assistant. You generate concise, professional commit messages in Conventional Commits format based on diffs. Output ONLY the raw commit message text."
            },
            {"role": "user", "content": prompt}
        ],
        "temperature": 0.2
    }

    try:
        req = urllib.request.Request(
            url,
            data=json.dumps(data).encode('utf-8'),
            headers={
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {GROQ_API_KEY}',
                'User-Agent': 'Mozilla/5.0 (ArchLinux; KDE Plasma) AI-Autocommit-Script/1.0'
            }
        )
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            return result['choices'][0]['message']['content'].strip()

    except urllib.error.HTTPError as e:
        print(f"[!] Groq API Error: {e.code} - {e.reason}")
        return None
    except Exception as e:
        print(f"[!] Groq Connection Error: {e}")
        return None

def call_ollama_api(prompt):
    """Calls local Ollama API."""
    data = {
        "model": OLLAMA_MODEL,
        "prompt": f"System: You are a git commit generator. Output ONLY the raw message.\nUser: {prompt}",
        "stream": False,
        "temperature": 0.2
    }
    try:
        req = urllib.request.Request(
            OLLAMA_API_URL,
            data=json.dumps(data).encode('utf-8'),
            headers={'Content-Type': 'application/json'}
        )
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            return result.get("response", "").strip()
    except Exception:
        print("[!] Ollama fallback failed. Is the service running?")
        return None

def clean_message(raw_msg):
    """Removes markdown code blocks and conversational filler."""
    if not raw_msg: return ""
    clean = re.sub(r'```\w*\n?', '', raw_msg)
    clean = re.sub(r'```', '', clean)
    # Remove common AI prefix filler
    clean = re.sub(r'^(Here is|Commit message:|Proposed commit:).*?\n', '', clean, flags=re.IGNORECASE)
    return clean.strip()

def generate_commit_message(diff_text):
    if len(diff_text) > 10000:
        diff_text = diff_text[:10000] + "\n...[Diff truncated]..."

    history = get_recent_commits(3)

    # REFINED PROMPT
    prompt = f"""Write a professional git commit message based on the following diff.

CONSTRAINTS:
1. Use the Conventional Commits format: <type>(<scope>): <description>
   - Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert.
2. The first line (subject) must be < 50 characters.
3. Use the imperative mood ("Add feature" not "Added feature").
4. If the change is complex, include a body with bullet points after one blank line.
5. Output ONLY the raw commit message. No explanations or markdown.

{f"REFERENCE HISTORY (Mimic this style if appropriate):" if history else ""}
{history}

DIFF TO ANALYZE:
{diff_text}
"""

    print(f"Generating message with {GROQ_MODEL}...")
    msg = call_groq_api(prompt)

    if not msg:
        print("Falling back to local Ollama...")
        msg = call_ollama_api(prompt)

    return clean_message(msg)

def open_editor(initial_content=""):
    editor = os.getenv('EDITOR', 'nano')
    with tempfile.NamedTemporaryFile(suffix=".txt", mode='w+', delete=False) as tf:
        tf.write(initial_content)
        tf_path = tf.name
    try:
        subprocess.call([editor, tf_path])
        with open(tf_path, 'r') as tf:
            return tf.read().strip()
    finally:
        if os.path.exists(tf_path):
            os.remove(tf_path)

def interactive_review(diff):
    msg = generate_commit_message(diff)
    if not msg:
        msg = "chore: manual commit (AI generation failed)"

    while True:
        print("\n" + "═"*40)
        print(" PROPOSED COMMIT MESSAGE")
        print("═"*40)
        print(msg)
        print("═"*40 + "\n")
        print("Actions: [a]ccept, [e]dit, [r]egenerate, [m]anual, [c]ancel")
        choice = input("Select action (default 'a'): ").lower().strip()

        if choice in ['a', '']:
            return msg
        elif choice == 'e':
            msg = open_editor(msg)
        elif choice == 'r':
            msg = generate_commit_message(diff)
        elif choice == 'm':
            msg = open_editor("")
        elif choice == 'c':
            print("Commit canceled.")
            sys.exit(0)

def main():
    if not os.path.exists(".git"):
        print("Error: Not a git repository.")
        sys.exit(1)

    # Check for changes
    status = run_command("git status --porcelain")
    if not status:
        print("No changes to commit.")
        sys.exit(0)

    print("Staging changes...")
    run_command("git add .")

    diff = run_command("git diff --cached", allow_error=True)
    if not diff:
        diff = status # Fallback to status if diff is empty

    final_msg = interactive_review(diff)

    # Final Commit
    tmp_file = ".git_commit_msg_tmp"
    with open(tmp_file, "w") as f:
        f.write(final_msg)

    run_command(f'git commit -F {tmp_file}')
    if os.path.exists(tmp_file): os.remove(tmp_file)

    # Push Section
    push_choice = input("\nPush to origin main? (y/n): ").lower().strip()
    if push_choice == 'y':
        try:
            print("Pushing...")
            run_command("git push origin main")
            print("Success!")
        except Exception as e:
            print(f"Push failed: {e}")

if __name__ == "__main__":
    main()
