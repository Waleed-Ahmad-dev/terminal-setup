#!/usr/bin/env python3
import subprocess
import os
import sys
import json
import urllib.request
import urllib.error
import tempfile
import re

# --- CONFIGURATION ---
# 1. GROQ (Hardcoded Key)
# GROQ_API_KEY = "API-KEY"
GROQ_MODEL = "llama-3.3-70b-versatile"

# 2. OLLAMA (Local Fallback)
OLLAMA_MODEL = "qwen2.5-coder:1.5b"
OLLAMA_API_URL = "http://localhost:11434/api/generate"
# ---------------------

def run_command(command, allow_error=False):
    """Runs a shell command and returns the output."""
    try:
        # Added stderr=subprocess.STDOUT to capture the actual error message
        result = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT)
        return result.decode('utf-8').strip()
    except subprocess.CalledProcessError as e:
        if allow_error:
            return e.output.decode('utf-8').strip()
        # This will now print the ACTUAL git error (e.g., "Please tell me who you are")
        print(f"\n[!] Command failed: {command}")
        print(f"[!] Error message: {e.output.decode('utf-8').strip()}")
        sys.exit(1)

def get_recent_commits(limit=5):
    """Fetches the last N commit messages to learn your style."""
    try:
        log = run_command(f"git log -n {limit} --pretty=format:'%B%n---COMMIT_DELIMITER---'", allow_error=True)
        if not log: return ""
        commits = log.split("---COMMIT_DELIMITER---")
        examples = []
        for c in commits:
            clean = c.strip()
            if clean:
                examples.append(f"Example:\n{clean}")
        return "\n\n".join(examples)
    except Exception:
        return ""

def call_groq_api(prompt):
    """Calls Groq API using the hardcoded key."""
    url = "https://api.groq.com/openai/v1/chat/completions"
    data = {
        "model": GROQ_MODEL,
        "messages": [
            {"role": "system", "content": "You are a git commit message generator. Output only the raw message without any markdown formatting."},
            {"role": "user", "content": prompt}
        ],
        "temperature": 0.1
    }

    try:
        req = urllib.request.Request(
            url,
            data=json.dumps(data).encode('utf-8'),
            headers={
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {GROQ_API_KEY}',
                # [FIX] Add a Browser User-Agent to bypass Cloudflare 403
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            }
        )
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            return result['choices'][0]['message']['content'].strip()

    except urllib.error.HTTPError as e:
        if e.code == 403:
            print("\n[!] GROQ ERROR 403: Forbidden")
            print("    This usually means your API Key is invalid or missing permissions.")
            print("    Check the steps below to fix your Project Settings.")
        elif e.code == 401:
            print("[!] Error: Invalid Groq API Key.")
        elif e.code == 429:
            print("[!] Error: Groq Rate Limit Exceeded.")
        else:
            print(f"[!] Groq API Error: {e}")
        return None
    except Exception as e:
        print(f"[!] Groq Connection Error: {e}")
        return None

def call_ollama_api(prompt):
    """Calls local Ollama API."""
    data = {
        "model": OLLAMA_MODEL,
        "prompt": prompt,
        "stream": False,
        "temperature": 0.1,
        "keep_alive": "24h"
    }
    try:
        req = urllib.request.Request(
            OLLAMA_API_URL,
            data=json.dumps(data).encode('utf-8'),
            headers={'Content-Type': 'application/json'}
        )
        with urllib.request.urlopen(req) as response:
            result = json.loads(response.read().decode('utf-8'))
            return result.get("response", "").strip()
    except urllib.error.URLError:
        print("Error: Ollama is not running. Run 'ollama serve' in background.")
        return None

def clean_message(raw_msg):
    """Removes markdown code blocks and conversational filler."""
    if not raw_msg: return ""
    clean = re.sub(r'```\w*\n?', '', raw_msg)
    clean = re.sub(r'```', '', clean)
    lines = clean.split('\n')
    final_lines = []
    started = False
    for line in lines:
        if not started:
            lower = line.lower().strip()
            if any(x in lower for x in ["here is", "commit message", "sure", "output"]):
                continue
            if line.strip() == "":
                continue
            started = True
        final_lines.append(line)
    return "\n".join(final_lines).strip()

def generate_commit_message(diff_text):
    if len(diff_text) > 8000:
        diff_text = diff_text[:8000] + "\n...[Diff truncated]..."

    history = get_recent_commits(5)

    prompt = f"""
    Instruction: Write a git commit message for the code changes below.
    STYLE GUIDE (Mimic the format of these examples):
    {history}
    Constraint: Do NOT include introductory text.
    Constraint: Output raw text only.
    CHANGES:
    {diff_text}
    """

    # --- TRY GROQ FIRST ---
    print(f"Generating with Groq ({GROQ_MODEL})...")
    msg = call_groq_api(prompt)

    if msg:
        return clean_message(msg)

    # --- FALLBACK TO OLLAMA ---
    print("Falling back to local Ollama due to API error...")
    msg = call_ollama_api(prompt)
    return clean_message(msg)

def open_editor(initial_content=""):
    editor = os.getenv('EDITOR', 'nano')
    with tempfile.NamedTemporaryFile(suffix=".txt", mode='w+', delete=False) as tf:
        tf.write(initial_content)
        tf_path = tf.name
    try:
        subprocess.call([editor, tf_path])
        with open(tf_path, 'r') as tf:
            return tf.read().strip()
    finally:
        if os.path.exists(tf_path):
            os.remove(tf_path)

def interactive_review(diff):
    msg = generate_commit_message(diff)
    if not msg:
        msg = "Auto-commit: Changes made (AI generation failed)"

    while True:
        print("\n" + "="*40)
        print("PROPOSED COMMIT MESSAGE")
        print("="*40)
        print(msg)
        print("="*40 + "\n")
        print("Actions: [a]ccept, [e]dit, [r]egenerate, [m]anual, [c]ancel")
        choice = input("Select action: ").lower().strip()

        if choice == 'a' or choice == '':
            return msg
        elif choice == 'e':
            msg = open_editor(msg)
        elif choice == 'r':
            print("Regenerating...")
            msg = generate_commit_message(diff)
        elif choice == 'm':
            msg = open_editor("")
        elif choice == 'c':
            sys.exit(0)

def main():
    if not os.path.exists(".git"):
        print("Initializing new git repository...")
        run_command("git init")
        run_command("git checkout -b main", allow_error=True)

    print("Adding files...")
    run_command("git add .")

    status = run_command("git status --porcelain")
    if not status:
        print("No changes to commit.")
        sys.exit(0)

    diff = run_command("git diff --cached", allow_error=True)
    if not diff: diff = status

    final_msg = interactive_review(diff)

    tmp_file = ".git_commit_msg_tmp"
    with open(tmp_file, "w") as f:
        f.write(final_msg)

    run_command(f'git commit -F {tmp_file}')
    if os.path.exists(tmp_file): os.remove(tmp_file)

    print("Pushing to origin main (Force)...")
    try:
        run_command("git push -f origin main")
        print("Success! Code pushed.")
    except Exception:
        print("Push failed. Remote 'origin' might be missing.")

if __name__ == "__main__":
    main()
